<!DOCTYPE html>
<html lang="zh-TW">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>æ™ºæ…§é†«ç™‚è‚Œè€åŠ›è©•ä¼°ç³»çµ±</title>
  
  <!-- p5.js CDN -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.7.0/p5.min.js"></script>
  
  <!-- MediaPipe CDN -->
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/pose/pose.js"></script>
  
  <!-- Chart.js for progress tracking -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
  
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      font-family: 'Noto Sans TC', -apple-system, BlinkMacSystemFont, sans-serif;
      -webkit-tap-highlight-color: transparent;
      touch-action: none;
      background: #f5f7fa;
    }
    
    main {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
    }
    
    video {
      display: none !important;
    }
    
    /* Loading Screen */
    #loading {
      position: fixed;
      inset: 0;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 9999;
      color: white;
    }
    
    #loading.hidden {
      display: none;
    }
    
    .spinner {
      border: 4px solid rgba(255, 255, 255, 0.3);
      border-top: 4px solid white;
      border-radius: 50%;
      width: 60px;
      height: 60px;
      animation: spin 1s linear infinite;
    }
    
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
    
    .medical-logo {
      font-size: 48px;
      margin-bottom: 20px;
    }
    
    /* Button styles */
    .btn {
      padding: 15px 30px;
      border-radius: 12px;
      border: none;
      font-size: 18px;
      font-weight: bold;
      cursor: pointer;
      transition: all 0.3s;
      font-family: inherit;
    }
    
    .btn-primary {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
    }
    
    .btn-primary:hover {
      transform: translateY(-2px);
      box-shadow: 0 8px 24px rgba(102, 126, 234, 0.4);
    }
    
    .btn-secondary {
      background: white;
      color: #667eea;
      border: 2px solid #667eea;
    }
    
    .btn-success {
      background: #10b981;
      color: white;
    }
    
    .btn-warning {
      background: #f59e0b;
      color: white;
    }
    
    .btn-danger {
      background: #ef4444;
      color: white;
    }
  </style>
</head>
<body>
  <div id="loading">
    <div class="medical-logo">ğŸ¥</div>
    <div class="spinner"></div>
    <div style="margin-top: 20px; font-size: 20px;">è¼‰å…¥ AI æ¨¡å‹ä¸­...</div>
  </div>
  
  <main></main>
  
  <script>
    // ==================== å…¨åŸŸè®Šæ•¸ ====================
    let video;
    let videoElement;  // åŸç”Ÿ HTML video å…ƒç´ 
    let videoStream;   // MediaStream ç‰©ä»¶
    let pose;
    let poseResults = null;
    let modelLoaded = false;
    
    // ç³»çµ±éšæ®µ
    let phase = 'loading'; // loading, home, patientInfo, testSelection, testInstructions, testing, result, history
    
    // å—æ¸¬è€…è³‡æ–™
    let patient = {
      name: '',
      age: '',
      gender: '',
      medicalHistory: [],
      id: null
    };
    
    // æ¸¬è©¦é¡å‹å®šç¾©
    const testTypes = {
      chairStand: {
        name: '30ç§’åç«™æ¸¬è©¦',
        nameEn: '30-Second Chair Stand',
        target: 'ä¸‹è‚¢è‚ŒåŠ›',
        duration: 30,
        targetCount: null,
        ageGroup: '60æ­²ä»¥ä¸Š',
        equipment: 'æœ‰æ‰¶æ‰‹çš„ç©©å›ºæ¤…å­',
        icon: 'ğŸª‘',
        description: 'è©•ä¼°ä¸‹è‚¢è‚ŒåŠ›èˆ‡åŠŸèƒ½æ€§è¡Œå‹•èƒ½åŠ›ï¼Œé æ¸¬è·Œå€’é¢¨éšª',
        instructions: [
          'ååœ¨æ¤…å­ä¸Šï¼ŒèƒŒéƒ¨æŒºç›´',
          'é›™è…³å¹³æ”¾åœ°é¢ï¼Œèˆ‡è‚©åŒå¯¬',
          'é›™æ‰‹äº¤å‰æ”¾èƒ¸å‰',
          'ç«™èµ·æ™‚è†è“‹å®Œå…¨ä¼¸ç›´',
          'åä¸‹æ™‚è‡€éƒ¨å®Œå…¨æ¥è§¸æ¤…é¢',
          '30ç§’å…§ç›¡å¯èƒ½å®Œæˆå¤šæ¬¡'
        ],
        contraindications: ['æ€¥æ€§ä¸‹èƒŒç—›', 'æœªæ§åˆ¶çš„é«˜è¡€å£“', 'è¿‘æœŸé«–/è†é—œç¯€æ‰‹è¡“']
      },
      armCurl: {
        name: '30ç§’æ‰‹è‡‚å½èˆ‰',
        nameEn: '30-Second Arm Curl',
        target: 'ä¸Šè‚¢è‚ŒåŠ›',
        duration: 30,
        targetCount: null,
        ageGroup: '60æ­²ä»¥ä¸Š',
        equipment: 'å•éˆ´ï¼ˆç”·5ç£…/å¥³3ç£…ï¼‰',
        icon: 'ğŸ’ª',
        description: 'è©•ä¼°ä¸Šè‚¢è‚ŒåŠ›èˆ‡æ—¥å¸¸ç”Ÿæ´»æ´»å‹•èƒ½åŠ›',
        instructions: [
          'ååœ¨æ¤…å­ä¸Šï¼ŒèƒŒéƒ¨æŒºç›´',
          'æ‰‹æŒå•éˆ´ï¼Œæ‰‹è‡‚è‡ªç„¶ä¸‹å‚',
          'æ‰‹æŒå‘å‰ï¼Œå½æ›²æ‰‹è‚˜',
          'å‰è‡‚é è¿‘è‚©è†€å¾Œæ”¾ä¸‹',
          'ä¿æŒä¸Šè‡‚å›ºå®šä¸å‹•',
          '30ç§’å…§ç›¡å¯èƒ½å®Œæˆå¤šæ¬¡'
        ],
        contraindications: ['è‚©é—œç¯€ç–¼ç—›', 'ç¶²çƒè‚˜', 'è…•éš§é“ç—‡å€™ç¾¤']
      },
      balance: {
        name: 'å–®è…³ç«™ç«‹æ¸¬è©¦',
        nameEn: 'One-Leg Stand Test',
        target: 'å¹³è¡¡èƒ½åŠ›',
        duration: 60,
        targetCount: null,
        ageGroup: 'å…¨å¹´é½¡',
        equipment: 'ç„¡',
        icon: 'âš–ï¸',
        description: 'è©•ä¼°éœæ…‹å¹³è¡¡èƒ½åŠ›ï¼Œé æ¸¬è·Œå€’é¢¨éšª',
        instructions: [
          'é›™æ‰‹å‰è…°æˆ–è‡ªç„¶ä¸‹å‚',
          'æŠ¬èµ·ä¸€è…³é›¢åœ°ç´„10å…¬åˆ†',
          'ç›¡å¯èƒ½ç¶­æŒå¹³è¡¡',
          'æ¸¬é‡èƒ½ç«™ç«‹çš„æ™‚é–“',
          'èº«é«”æ™ƒå‹•æˆ–è…³è½åœ°å³çµæŸ',
          'å…©è…³å„æ¸¬è©¦ä¸€æ¬¡'
        ],
        contraindications: ['åš´é‡éª¨è³ªç–é¬†', 'è¿‘æœŸéª¨æŠ˜', 'åš´é‡çœ©æšˆ']
      }
    };
    
    // ç•¶å‰æ¸¬è©¦
    let currentTest = null;
    let testSession = null;
    
    // æ¸¬è©¦æ•¸æ“š
    let repCount = 0;
    let currentState = null;
    let lastStateTime = null;
    let startTime = null;
    let endTime = null;
    let testDuration = 0;
    let qualityScores = [];
    let warnings = [];
    
    // è§’åº¦ç›¸é—œ
    let kneeAngle = null;
    let armAngle = null;
    let balanceTime = 0;
    let balanceLeg = null;
    
    // è¨ˆæ™‚å™¨
    let timerStartTime = 0;
    let displayTime = '00.00';
    
    // UI å…ƒç´ 
    let nameInput, ageInput;
    let medicalCheckboxes = {};
    
    // æ•¸æ“šç®¡ç†
    let testHistory = [];
    
    // ==================== p5.js è¨­å®š ====================
    
    function setup() {
      createCanvas(windowWidth, windowHeight);
      
      // å‰µå»ºåŸç”Ÿ video å…ƒç´ 
      videoElement = document.createElement('video');
      videoElement.setAttribute('playsinline', '');  // iOS éœ€è¦
      videoElement.setAttribute('autoplay', '');
      videoElement.style.display = 'none';
      document.body.appendChild(videoElement);
      
      // ä½¿ç”¨åŸç”Ÿ getUserMedia å•Ÿå‹•æ”å½±æ©Ÿ
      startCamera();
      
      initPose();
      loadTestHistory();
      
      textFont('sans-serif');
    }
    
    // åŸç”Ÿæ–¹å¼å•Ÿå‹•æ”å½±æ©Ÿ
    async function startCamera() {
      try {
        console.log('å˜—è©¦å•Ÿå‹•æ”å½±æ©Ÿ...');
        
        // æª¢æŸ¥ç€è¦½å™¨æ”¯æ´
        if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
          console.error('æ­¤ç€è¦½å™¨ä¸æ”¯æ´ getUserMedia');
          alert('æ‚¨çš„ç€è¦½å™¨ä¸æ”¯æ´æ”å½±æ©ŸåŠŸèƒ½ï¼Œè«‹ä½¿ç”¨ Chrome æˆ–æ›´æ–° Safari');
          return;
        }
        
        const constraints = {
          video: {
            facingMode: 'user',
            width: { ideal: 640 },
            height: { ideal: 480 }
          },
          audio: false
        };
        
        videoStream = await navigator.mediaDevices.getUserMedia(constraints);
        console.log('âœ… æˆåŠŸå–å¾—æ”å½±æ©Ÿä¸²æµ');
        
        videoElement.srcObject = videoStream;
        
        // ç­‰å¾… video æº–å‚™å¥½
        videoElement.onloadedmetadata = () => {
          console.log('âœ… å½±ç‰‡å…ƒæ•¸æ“šå·²è¼‰å…¥');
          videoElement.play();
        };
        
        // ç‚º p5.js å‰µå»ºå…¼å®¹ç‰©ä»¶
        video = {
          elt: videoElement,
          width: 640,
          height: 480
        };
        
      } catch (err) {
        console.error('æ”å½±æ©Ÿå•Ÿå‹•å¤±æ•—:', err);
        let errorMsg = 'ç„¡æ³•å•Ÿå‹•æ”å½±æ©Ÿ\n\n';
        
        if (err.name === 'NotAllowedError') {
          errorMsg += 'åŸå› ï¼šæ¬Šé™è¢«æ‹’çµ•\nè«‹å…è¨±æ­¤ç¶²ç«™ä½¿ç”¨æ”å½±æ©Ÿ';
        } else if (err.name === 'NotFoundError') {
          errorMsg += 'åŸå› ï¼šæ‰¾ä¸åˆ°æ”å½±æ©Ÿ\nè«‹ç¢ºèªè£ç½®æœ‰æ”å½±æ©Ÿ';
        } else if (err.name === 'NotReadableError') {
          errorMsg += 'åŸå› ï¼šæ”å½±æ©Ÿè¢«ä½”ç”¨\nè«‹é—œé–‰å…¶ä»–ä½¿ç”¨æ”å½±æ©Ÿçš„ç¨‹å¼';
        } else {
          errorMsg += 'åŸå› ï¼š' + err.message;
        }
        
        alert(errorMsg);
      }
    }
    
    function draw() {
      switch(phase) {
        case 'loading':
          drawLoading();
          break;
        case 'home':
          drawHome();
          break;
        case 'patientInfo':
          drawPatientInfo();
          break;
        case 'testSelection':
          drawTestSelection();
          break;
        case 'testInstructions':
          drawTestInstructions();
          break;
        case 'testing':
          drawTesting();
          break;
        case 'result':
          drawResult();
          break;
        case 'history':
          drawHistory();
          break;
      }
    }
    
    // ==================== MediaPipe åˆå§‹åŒ– ====================
    
    function initPose() {
      pose = new Pose({
        locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/pose/${file}`
      });
      
      pose.setOptions({
        modelComplexity: 1,
        smoothLandmarks: true,
        minDetectionConfidence: 0.5,
        minTrackingConfidence: 0.5
      });
      
      pose.onResults(gotPose);
      
      pose.initialize().then(() => {
        modelLoaded = true;
        document.getElementById('loading').classList.add('hidden');
        phase = 'home';
        detectPose();
      }).catch((error) => {
        console.error('æ¨¡å‹è¼‰å…¥å¤±æ•—:', error);
      });
    }
    
    function gotPose(results) {
      poseResults = results;
    }
    
    async function detectPose() {
      if (modelLoaded && video && video.elt && video.elt.readyState === 4) {
        await pose.send({ image: video.elt });
      }
      requestAnimationFrame(detectPose);
    }
    
    // ==================== ç¹ªè£½å‡½å¼ ====================
    
    function drawLoading() {
      background(240);
    }
    
    function drawHome() {
      // é†«ç™‚é¢¨æ ¼ä¸»é 
      background(245, 247, 250);
      
      // æ¨™é¡Œå€
      fill(102, 126, 234);
      noStroke();
      rect(0, 0, width, 200);
      
      fill(255);
      textAlign(CENTER, CENTER);
      textSize(36);
      textStyle(BOLD);
      text('ğŸ¥ æ™ºæ…§é†«ç™‚è‚Œè€åŠ›è©•ä¼°ç³»çµ±', width/2, 70);
      
      textSize(18);
      textStyle(NORMAL);
      text('AI-Powered Muscular Endurance Assessment', width/2, 110);
      
      textSize(16);
      fill(255, 255, 255, 200);
      text('Professional Healthcare Solution', width/2, 140);
      
      // ä¸»è¦æŒ‰éˆ•
      let btnY = 280;
      let btnSpacing = 100;
      
      // é–‹å§‹æ–°æ¸¬è©¦æŒ‰éˆ•
      drawButton(width/2 - 150, btnY, 300, 70, 'é–‹å§‹æ–°æ¸¬è©¦', '667eea');
      
      // æŸ¥çœ‹æ­·å²è¨˜éŒ„æŒ‰éˆ•
      drawButton(width/2 - 150, btnY + btnSpacing, 300, 70, 'æ­·å²è¨˜éŒ„', 'ffffff', true);
      
      // ç³»çµ±è³‡è¨Š
      textAlign(CENTER);
      fill(100);
      textSize(14);
      text('ç³»çµ±ç‰ˆæœ¬ v1.0 | AIæ¨¡å‹ï¼šMediaPipe Pose', width/2, height - 40);
    }
    
    function drawPatientInfo() {
      background(245, 247, 250);
      
      // æ¨™é¡Œ
      drawHeader('å—æ¸¬è€…è³‡æ–™');
      
      // è¡¨å–®å¡ç‰‡
      let cardW = min(width * 0.9, 600);
      let cardH = min(height * 0.7, 650);  // èª¿æ•´é«˜åº¦
      let cardX = (width - cardW) / 2;
      let cardY = 150;
      
      fill(255);
      noStroke();
      drawRoundRect(cardX, cardY, cardW, cardH, 20);
      
      // è¡¨å–®å…§å®¹
      fill(60);
      textAlign(LEFT);
      textSize(18);
      textStyle(BOLD);
      
      let formX = cardX + 40;
      let formY = cardY + 40;
      
      text('åŸºæœ¬è³‡æ–™', formX, formY);
      
      // å§“åæ¬„ä½ - å¯é»æ“Šç·¨è¼¯
      textStyle(NORMAL);
      textSize(16);
      fill(100);
      text('å§“å', formX, formY + 50);
      
      // å§“åé¡¯ç¤ºæ¡†
      let nameBoxY = formY + 70;
      let nameBoxH = max(height * 0.07, 50);
      fill(patient.name ? 255 : 250);
      stroke(patient.name ? 102 : 220, patient.name ? 126 : 220, patient.name ? 234 : 220);
      strokeWeight(2);
      drawRoundRect(formX, nameBoxY, cardW - 80, nameBoxH, 10);
      
      fill(patient.name ? 60 : 180);
      noStroke();
      textAlign(LEFT, CENTER);
      textSize(max(width * 0.045, 16));
      text(patient.name || 'é»æ­¤è¼¸å…¥å§“å', formX + 15, nameBoxY + nameBoxH/2);
      
      // å¹´é½¡æ¬„ä½
      let ageY = nameBoxY + nameBoxH + 30;
      fill(100);
      textAlign(LEFT, TOP);
      textSize(16);
      text('å¹´é½¡', formX, ageY);
      
      // å¹´é½¡é¡¯ç¤ºæ¡†
      let ageBoxY = ageY + 20;
      let ageBoxH = max(height * 0.07, 50);
      fill(patient.age ? 255 : 250);
      stroke(patient.age ? 102 : 220, patient.age ? 126 : 220, patient.age ? 234 : 220);
      strokeWeight(2);
      drawRoundRect(formX, ageBoxY, cardW - 80, ageBoxH, 10);
      
      fill(patient.age ? 60 : 180);
      noStroke();
      textAlign(LEFT, CENTER);
      textSize(max(width * 0.045, 16));
      text(patient.age || 'é»æ­¤è¼¸å…¥å¹´é½¡', formX + 15, ageBoxY + ageBoxH/2);
      
      // æ€§åˆ¥
      let genderY = ageBoxY + ageBoxH + 30;
      fill(100);
      textAlign(LEFT, TOP);
      textSize(16);
      text('æ€§åˆ¥', formX, genderY);
      
      drawGenderButtons(formX, genderY + 30);
      
      // ä¸‹ä¸€æ­¥æŒ‰éˆ•ï¼ˆå›ºå®šåœ¨åº•éƒ¨ï¼‰
      let canProceed = patient.name && patient.age && patient.gender;
      let btnY = height - 100;  // å›ºå®šè·é›¢åº•éƒ¨ 100px
      drawButton(width/2 - 100, btnY, 200, 60, 
                 'ä¸‹ä¸€æ­¥', canProceed ? '667eea' : 'cccccc');
      
      // è¿”å›æŒ‰éˆ•
      drawBackButton();
    }
    
    function drawTestSelection() {
      background(245, 247, 250);
      
      drawHeader('é¸æ“‡æ¸¬è©¦é …ç›®');
      
      let startY = 150;
      let cardSpacing = 20;
      let cardH = 180;
      let cardW = min(width * 0.9, 500);
      let cardX = (width - cardW) / 2;
      
      let tests = Object.keys(testTypes);
      
      for (let i = 0; i < tests.length; i++) {
        let test = testTypes[tests[i]];
        let y = startY + i * (cardH + cardSpacing);
        
        drawTestCard(cardX, y, cardW, cardH, test, tests[i]);
      }
      
      drawBackButton();
    }
    
    function drawTestInstructions() {
      background(245, 247, 250);
      
      if (!currentTest) return;
      
      let test = testTypes[currentTest];
      
      drawHeader(test.icon + ' ' + test.name);
      
      let cardW = min(width * 0.9, 700);
      let cardX = (width - cardW) / 2;
      let cardY = 150;
      let cardH = min(height - cardY - 140, 650);  // å‹•æ…‹é«˜åº¦ï¼Œçµ¦æŒ‰éˆ•ç•™ç©ºé–“
      
      fill(255);
      noStroke();
      drawRoundRect(cardX, cardY, cardW, cardH, 20);
      
      let contentX = cardX + 30;
      let contentY = cardY + 30;
      let contentW = cardW - 60;
      
      // æ¸¬è©¦èªªæ˜
      fill(60);
      textSize(max(width * 0.04, 16));
      textStyle(BOLD);
      text('æ¸¬è©¦èªªæ˜', contentX, contentY);
      
      textStyle(NORMAL);
      fill(100);
      textSize(max(width * 0.035, 14));
      let descY = contentY + 35;
      text(test.description, contentX, descY, contentW);
      
      // æ“ä½œæ­¥é©Ÿ
      let stepY = descY + 80;
      fill(60);
      textStyle(BOLD);
      textSize(max(width * 0.04, 16));
      text('æ“ä½œæ­¥é©Ÿ', contentX, stepY);
      
      textStyle(NORMAL);
      fill(100);
      textSize(max(width * 0.035, 14));
      let lineHeight = max(height * 0.04, 30);  // å‹•æ…‹è¡Œé«˜
      stepY += 35;
      
      for (let i = 0; i < test.instructions.length; i++) {
        text(`${i+1}. ${test.instructions[i]}`, contentX, stepY, contentW);
        stepY += lineHeight;
      }
      
      // ç¦å¿Œç—‡è­¦å‘Šï¼ˆå¦‚æœç©ºé–“è¶³å¤ æ‰é¡¯ç¤ºï¼‰
      if (test.contraindications.length > 0 && stepY < cardY + cardH - 100) {
        stepY += 20;
        fill(239, 68, 68);
        textStyle(BOLD);
        textSize(max(width * 0.038, 15));
        text('âš ï¸ æ³¨æ„äº‹é …', contentX, stepY);
        
        textStyle(NORMAL);
        textSize(max(width * 0.032, 13));
        stepY += 30;
        
        for (let contra of test.contraindications) {
          if (stepY < cardY + cardH - 40) {  // ç¢ºä¿ä¸è¶…å‡ºå¡ç‰‡
            text('â€¢ ' + contra, contentX + 10, stepY, contentW - 20);
            stepY += 28;
          }
        }
      }
      
      // é–‹å§‹æ¸¬è©¦æŒ‰éˆ• - å›ºå®šåœ¨åº•éƒ¨
      let btnY = height - 120;
      drawButton(width/2 - 100, btnY, 200, 60, 'é–‹å§‹æ¸¬è©¦', '10b981');
      
      // è¿”å›æŒ‰éˆ•
      drawBackButton();
    }
    
    function drawTesting() {
      background(0);
      
      // é¡¯ç¤ºå½±ç‰‡ - ä½¿ç”¨åŸç”Ÿ video å…ƒç´ 
      if (videoElement && videoElement.readyState === videoElement.HAVE_ENOUGH_DATA) {
        push();
        translate(width, 0);
        scale(-1, 1);
        // ä½¿ç”¨ drawingContext ç›´æ¥ç¹ªè£½ video
        drawingContext.drawImage(videoElement, 0, 0, width, height);
        pop();
      }
      
      // ç¹ªè£½éª¨æ¶
      if (poseResults && poseResults.poseLandmarks) {
        drawSkeleton(poseResults.poseLandmarks);
        updateTestLogic(poseResults.poseLandmarks);
      }
      
      // æ¸¬è©¦ UI
      drawTestUI();
    }
    
    function drawResult() {
      background(245, 247, 250);
      
      if (!testSession) return;
      
      drawHeader('ğŸ“Š æ¸¬è©¦å ±å‘Š');
      
      let cardW = min(width * 0.9, 700);
      let cardX = (width - cardW) / 2;
      let cardY = 150;
      let cardH = height - cardY - 120;
      
      fill(255);
      noStroke();
      drawRoundRect(cardX, cardY, cardW, cardH, 20);
      
      let contentX = cardX + 40;
      let contentY = cardY + 40;
      
      // æ¸¬è©¦åç¨±
      fill(60);
      textSize(18);
      textStyle(BOLD);
      text(testTypes[currentTest].name, contentX, contentY);
      
      // æ¸¬è©¦çµæœ
      contentY += 50;
      fill(102, 126, 234);
      textSize(48);
      textStyle(BOLD);
      text(testSession.result.value, contentX, contentY);
      
      contentY += 50;
      fill(100);
      textSize(16);
      textStyle(NORMAL);
      text(`æ¸¬è©¦æ™‚é–“ï¼š${testSession.result.duration}ç§’`, contentX, contentY);
      
      // è©•ä¼°ç­‰ç´š
      contentY += 50;
      drawRatingBadge(contentX, contentY, testSession.result.rating);
      
      // å‹•ä½œå“è³ª
      if (qualityScores.length > 0) {
        contentY += 80;
        fill(60);
        textSize(16);
        textStyle(BOLD);
        text('å‹•ä½œå“è³ªåˆ†æ', contentX, contentY);
        
        contentY += 30;
        let avgQuality = qualityScores.reduce((a,b) => a+b) / qualityScores.length;
        drawQualityBar(contentX, contentY, avgQuality);
      }
      
      // å»ºè­°
      contentY += 80;
      fill(60);
      textSize(16);
      textStyle(BOLD);
      text('å°ˆæ¥­å»ºè­°', contentX, contentY);
      
      contentY += 30;
      fill(100);
      textSize(14);
      textStyle(NORMAL);
      text(testSession.result.recommendation, contentX, contentY, cardW - 80);
      
      // æŒ‰éˆ•
      drawButton(width/2 - 220, height - 100, 200, 60, 'å„²å­˜å ±å‘Š', '10b981');
      drawButton(width/2 + 20, height - 100, 200, 60, 'è¿”å›é¦–é ', '667eea');
    }
    
    function drawHistory() {
      background(245, 247, 250);
      
      drawHeader('ğŸ“ˆ æ­·å²è¨˜éŒ„');
      
      // TODO: å¯¦ä½œæ­·å²è¨˜éŒ„é¡¯ç¤º
      
      fill(100);
      textAlign(CENTER);
      textSize(16);
      text('æ­·å²è¨˜éŒ„åŠŸèƒ½é–‹ç™¼ä¸­...', width/2, height/2);
      
      drawBackButton();
    }
    
    // ==================== æ¸¬è©¦é‚è¼¯ ====================
    
    function updateTestLogic(landmarks) {
      if (!currentTest || !testSession) return;
      
      switch(currentTest) {
        case 'chairStand':
          updateChairStand(landmarks);
          break;
        case 'armCurl':
          updateArmCurl(landmarks);
          break;
        case 'balance':
          updateBalance(landmarks);
          break;
      }
      
      // æª¢æŸ¥æ™‚é–“
      if (testTypes[currentTest].duration) {
        let elapsed = (millis() - timerStartTime) / 1000;
        if (elapsed >= testTypes[currentTest].duration) {
          endTest();
        }
      }
    }
    
    function updateChairStand(landmarks) {
      let hip = landmarks[24];
      let knee = landmarks[26];
      let ankle = landmarks[28];
      
      if (!hip || !knee || !ankle) return;
      
      kneeAngle = calculateAngle(hip, knee, ankle);
      
      let newState = null;
      
      if (kneeAngle < 100) {
        newState = 'Sit';
      } else if (kneeAngle > 140) {
        newState = 'Stand';
      }
      
      if (newState && newState !== currentState) {
        if (newState === 'Stand' && currentState === 'Sit') {
          let elapsed = Date.now() - lastStateTime;
          if (elapsed > 300) {
            repCount++;
            evaluateMovementQuality(landmarks);
            playSound('count');
          }
        }
        currentState = newState;
        lastStateTime = Date.now();
      }
    }
    
    function updateArmCurl(landmarks) {
      let shoulder = landmarks[12];
      let elbow = landmarks[14];
      let wrist = landmarks[16];
      
      if (!shoulder || !elbow || !wrist) return;
      
      armAngle = calculateAngle(shoulder, elbow, wrist);
      
      let newState = null;
      
      if (armAngle < 60) {
        newState = 'Curled';
      } else if (armAngle > 160) {
        newState = 'Extended';
      }
      
      if (newState && newState !== currentState) {
        if (newState === 'Extended' && currentState === 'Curled') {
          let elapsed = Date.now() - lastStateTime;
          if (elapsed > 300) {
            repCount++;
            evaluateMovementQuality(landmarks);
            playSound('count');
          }
        }
        currentState = newState;
        lastStateTime = Date.now();
      }
    }
    
    function updateBalance(landmarks) {
      let leftAnkle = landmarks[27];
      let rightAnkle = landmarks[28];
      let leftKnee = landmarks[25];
      let rightKnee = landmarks[26];
      
      if (!leftAnkle || !rightAnkle) return;
      
      // æª¢æ¸¬å–®è…³ç«™ç«‹
      if (leftKnee.y < rightKnee.y - 0.1 && leftAnkle.visibility < 0.3) {
        balanceLeg = 'right';
        balanceTime++;
      } else if (rightKnee.y < leftKnee.y - 0.1 && rightAnkle.visibility < 0.3) {
        balanceLeg = 'left';
        balanceTime++;
      } else {
        balanceLeg = null;
      }
    }
    
    function evaluateMovementQuality(landmarks) {
      let quality = 100;
      let currentWarnings = [];
      
      // æª¢æŸ¥è†è“‹å°é½Š
      if (currentTest === 'chairStand') {
        let leftKnee = landmarks[25];
        let rightKnee = landmarks[26];
        let kneeDistance = abs(leftKnee.x - rightKnee.x);
        
        if (kneeDistance < 0.05) {
          quality -= 10;
          currentWarnings.push('è†è“‹å…§å¤¾');
        }
        
        // æª¢æŸ¥è»€å¹¹è§’åº¦
        let shoulder = landmarks[12];
        let hip = landmarks[24];
        let trunkAngle = atan2(hip.y - shoulder.y, hip.x - shoulder.x) * 180 / PI;
        
        if (abs(trunkAngle) > 30) {
          quality -= 10;
          currentWarnings.push('è»€å¹¹å‰å‚¾éåº¦');
        }
      }
      
      qualityScores.push(quality);
      warnings = warnings.concat(currentWarnings);
    }
    
    function startTest() {
      testSession = {
        patientId: patient.id,
        testType: currentTest,
        startTime: Date.now(),
        endTime: null,
        result: null
      };
      
      repCount = 0;
      currentState = null;
      lastStateTime = Date.now();
      timerStartTime = millis();
      qualityScores = [];
      warnings = [];
      balanceTime = 0;
      
      phase = 'testing';
    }
    
    function endTest() {
      testSession.endTime = Date.now();
      let duration = (testSession.endTime - testSession.startTime) / 1000;
      
      // è¨ˆç®—çµæœ
      let value, unit, rating, recommendation;
      
      switch(currentTest) {
        case 'chairStand':
        case 'armCurl':
          value = repCount;
          unit = 'æ¬¡';
          rating = getRating(currentTest, repCount, patient.age, patient.gender);
          recommendation = getRecommendation(currentTest, rating);
          break;
        case 'balance':
          value = (balanceTime / 60).toFixed(1);
          unit = 'ç§’';
          rating = getBalanceRating(balanceTime / 60);
          recommendation = getRecommendation('balance', rating);
          break;
      }
      
      testSession.result = {
        value: value + unit,
        duration: duration.toFixed(1),
        rating: rating,
        recommendation: recommendation,
        qualityScore: qualityScores.length > 0 ? 
          (qualityScores.reduce((a,b) => a+b) / qualityScores.length).toFixed(0) : null,
        warnings: [...new Set(warnings)]
      };
      
      // å„²å­˜è¨˜éŒ„
      saveTestResult(testSession);
      
      phase = 'result';
    }
    
    // ==================== è©•ä¼°ç³»çµ± ====================
    
    function getRating(testType, count, age, gender) {
      // ç°¡åŒ–çš„è©•ä¼°æ¨™æº–
      const standards = {
        chairStand: {
          male: { excellent: 19, good: 16, average: 13, poor: 10 },
          female: { excellent: 17, good: 14, average: 11, poor: 8 }
        },
        armCurl: {
          male: { excellent: 20, good: 17, average: 14, poor: 11 },
          female: { excellent: 18, good: 15, average: 12, poor: 9 }
        }
      };
      
      let std = standards[testType][gender === 'ç”·' ? 'male' : 'female'];
      
      if (count >= std.excellent) return 'å„ªç§€';
      if (count >= std.good) return 'è‰¯å¥½';
      if (count >= std.average) return 'æ™®é€š';
      if (count >= std.poor) return 'éœ€æ”¹å–„';
      return 'é«˜é¢¨éšª';
    }
    
    function getBalanceRating(seconds) {
      if (seconds >= 10) return 'å„ªç§€';
      if (seconds >= 5) return 'è‰¯å¥½';
      if (seconds >= 3) return 'æ™®é€š';
      return 'éœ€æ”¹å–„';
    }
    
    function getRecommendation(testType, rating) {
      const recommendations = {
        chairStand: {
          'å„ªç§€': 'è‚ŒåŠ›è¡¨ç¾å„ªç•°ï¼å»ºè­°ç¶­æŒç›®å‰é‹å‹•ç¿’æ…£ï¼Œå¯å˜—è©¦å¢åŠ é‹å‹•å¼·åº¦ã€‚',
          'è‰¯å¥½': 'è‚ŒåŠ›ç‹€æ³è‰¯å¥½ï¼å»ºè­°æ¯é€±é€²è¡Œ2-3æ¬¡é˜»åŠ›è¨“ç·´ä»¥ç¶­æŒè‚ŒåŠ›ã€‚',
          'æ™®é€š': 'å»ºè­°å¢åŠ ä¸‹è‚¢è‚ŒåŠ›è¨“ç·´ï¼Œå¦‚åå§¿æŠ¬è…¿ã€ç‰†å£æ·±è¹²ç­‰é‹å‹•ã€‚',
          'éœ€æ”¹å–„': 'å»ºè­°è«®è©¢ç‰©ç†æ²»ç™‚å¸«ï¼Œé€²è¡Œæ¼¸é€²å¼è‚ŒåŠ›è¨“ç·´è¨ˆç•«ã€‚',
          'é«˜é¢¨éšª': 'å»ºè­°å„˜é€Ÿå°±é†«è©•ä¼°ï¼Œä¸¦åœ¨å°ˆæ¥­æŒ‡å°ä¸‹é€²è¡Œå¾©å¥è¨“ç·´ã€‚'
        },
        armCurl: {
          'å„ªç§€': 'ä¸Šè‚¢è‚ŒåŠ›è¡¨ç¾å„ªç•°ï¼å»ºè­°ç¶­æŒç›®å‰é‹å‹•ç¿’æ…£ã€‚',
          'è‰¯å¥½': 'ä¸Šè‚¢è‚ŒåŠ›ç‹€æ³è‰¯å¥½ï¼å¯é©åº¦å¢åŠ é˜»åŠ›è¨“ç·´å¼·åº¦ã€‚',
          'æ™®é€š': 'å»ºè­°å¢åŠ ä¸Šè‚¢è‚ŒåŠ›è¨“ç·´ï¼Œå¦‚å•éˆ´å½èˆ‰ã€æ¨èˆ‰ç­‰é‹å‹•ã€‚',
          'éœ€æ”¹å–„': 'å»ºè­°è«®è©¢å°ˆæ¥­äººå“¡ï¼Œåˆ¶å®šå€‹äººåŒ–è¨“ç·´è¨ˆç•«ã€‚',
          'é«˜é¢¨éšª': 'å»ºè­°å°±é†«è©•ä¼°ï¼Œé¿å…éåº¦è² é‡è¨“ç·´ã€‚'
        },
        balance: {
          'å„ªç§€': 'å¹³è¡¡èƒ½åŠ›å„ªç•°ï¼å»ºè­°ç¶­æŒç›®å‰é‹å‹•ç¿’æ…£ã€‚',
          'è‰¯å¥½': 'å¹³è¡¡èƒ½åŠ›è‰¯å¥½ï¼å¯å˜—è©¦æ›´å…·æŒ‘æˆ°æ€§çš„å¹³è¡¡è¨“ç·´ã€‚',
          'æ™®é€š': 'å»ºè­°é€²è¡Œå¹³è¡¡è¨“ç·´ï¼Œå¦‚å–®è…³ç«™ç«‹ã€å¤ªæ¥µæ‹³ç­‰ã€‚',
          'éœ€æ”¹å–„': 'å¹³è¡¡èƒ½åŠ›éœ€åŠ å¼·ï¼Œå»ºè­°è«®è©¢ç‰©ç†æ²»ç™‚å¸«é€²è¡Œå¹³è¡¡è¨“ç·´ï¼Œä¸¦æ³¨æ„å±…å®¶ç’°å¢ƒå®‰å…¨ã€‚'
        }
      };
      
      return recommendations[testType][rating] || 'è«‹è«®è©¢å°ˆæ¥­é†«ç™‚äººå“¡ã€‚';
    }
    
    // ==================== UI è¼”åŠ©å‡½å¼ ====================
    
    function drawButton(x, y, w, h, label, color='667eea', outlined=false) {
      push();
      
      let isHover = mouseX > x && mouseX < x + w && mouseY > y && mouseY < y + h;
      
      if (outlined) {
        stroke(color === '667eea' ? color : '#' + color);
        strokeWeight(2);
        fill(255);
      } else {
        noStroke();
        if (color === 'cccccc') {
          fill(204, 204, 204);
        } else {
          fill('#' + color);
        }
      }
      
      if (isHover && color !== 'cccccc') {
        drawingContext.shadowBlur = 15;
        drawingContext.shadowColor = `rgba(${color === '667eea' ? '102, 126, 234' : '16, 185, 129'}, 0.5)`;
      }
      
      drawRoundRect(x, y, w, h, 12);
      
      drawingContext.shadowBlur = 0;
      
      fill(outlined ? '#' + color : 255);
      noStroke();
      textAlign(CENTER, CENTER);
      textSize(18);
      textStyle(BOLD);
      text(label, x + w/2, y + h/2);
      
      pop();
    }
    
    function drawHeader(title) {
      fill(102, 126, 234);
      noStroke();
      rect(0, 0, width, 120);
      
      fill(255);
      textAlign(CENTER, CENTER);
      textSize(28);
      textStyle(BOLD);
      text(title, width/2, 60);
    }
    
    function drawBackButton() {
      let x = 20;
      let y = 20;
      let size = 50;
      
      fill(255, 255, 255, 200);
      noStroke();
      circle(x + size/2, y + size/2, size);
      
      fill(102, 126, 234);
      textAlign(CENTER, CENTER);
      textSize(24);
      text('â†', x + size/2, y + size/2);
    }
    
    function drawRoundRect(x, y, w, h, r) {
      beginShape();
      vertex(x + r, y);
      vertex(x + w - r, y);
      quadraticVertex(x + w, y, x + w, y + r);
      vertex(x + w, y + h - r);
      quadraticVertex(x + w, y + h, x + w - r, y + h);
      vertex(x + r, y + h);
      quadraticVertex(x, y + h, x, y + h - r);
      vertex(x, y + r);
      quadraticVertex(x, y, x + r, y);
      endShape(CLOSE);
    }
    
    function drawTestCard(x, y, w, h, test, testKey) {
      push();
      
      let isHover = mouseX > x && mouseX < x + w && mouseY > y && mouseY < y + h;
      
      fill(255);
      noStroke();
      
      if (isHover) {
        drawingContext.shadowBlur = 20;
        drawingContext.shadowColor = 'rgba(102, 126, 234, 0.3)';
      }
      
      drawRoundRect(x, y, w, h, 15);
      
      drawingContext.shadowBlur = 0;
      
      // åœ–æ¨™
      textAlign(LEFT, CENTER);
      textSize(48);
      text(test.icon, x + 30, y + h/2);
      
      // æ–‡å­—è³‡è¨Š
      let textX = x + 100;
      
      fill(60);
      textSize(20);
      textStyle(BOLD);
      textAlign(LEFT, TOP);
      text(test.name, textX, y + 30);
      
      fill(100);
      textSize(14);
      textStyle(NORMAL);
      text(`ç›®æ¨™ï¼š${test.target}`, textX, y + 60);
      text(`æ™‚é–“ï¼š${test.duration ? test.duration + 'ç§’' : 'ä¸é™'}`, textX, y + 85);
      text(`é©ç”¨ï¼š${test.ageGroup}`, textX, y + 110);
      
      // ç®­é ­
      fill(102, 126, 234);
      textAlign(RIGHT, CENTER);
      textSize(24);
      text('â†’', x + w - 30, y + h/2);
      
      pop();
    }
    
    function drawGenderButtons(x, y) {
      let genders = ['ç”·', 'å¥³'];
      let btnW = max(width * 0.25, 100);   // è¢å¹•å¯¬åº¦ 25%ï¼Œæœ€å° 100px
      let btnH = max(height * 0.065, 50);  // è¢å¹•é«˜åº¦ 6.5%ï¼Œæœ€å° 50px
      let spacing = max(width * 0.04, 15); // è‡ªå‹•é–“è·
      
      for (let i = 0; i < genders.length; i++) {
        let btnX = x + i * (btnW + spacing);
        let isSelected = patient.gender === genders[i];
        let isHover = mouseX > btnX && mouseX < btnX + btnW && 
                      mouseY > y && mouseY < y + btnH;
        
        if (isSelected) {
          fill(102, 126, 234);
        } else {
          fill(240);
        }
        
        noStroke();
        drawRoundRect(btnX, y, btnW, btnH, 10);
        
        fill(isSelected ? 255 : 100);
        textAlign(CENTER, CENTER);
        textSize(max(width * 0.045, 16));  // è‡ªå‹•å­—é«”å¤§å°
        text(genders[i], btnX + btnW/2, y + btnH/2);
      }
    }
    
    function drawMedicalHistory(x, y) {
      let conditions = ['é«˜è¡€å£“', 'ç³–å°¿ç—…', 'å¿ƒè‡Ÿç—…', 'é—œç¯€ç‚', 'éª¨è³ªç–é¬†'];
      let btnW = max(width * 0.26, 110);   // è¢å¹•å¯¬åº¦ 26%ï¼Œæœ€å° 110px
      let btnH = max(height * 0.055, 45);  // è¢å¹•é«˜åº¦ 5.5%ï¼Œæœ€å° 45px
      let spacing = max(width * 0.02, 10); // è‡ªå‹•é–“è·
      let cols = width < 500 ? 2 : 3;      // å°è¢å¹•é¡¯ç¤º 2 æ¬„ï¼Œå¤§è¢å¹• 3 æ¬„
      
      for (let i = 0; i < conditions.length; i++) {
        let col = i % cols;
        let row = floor(i / cols);
        let btnX = x + col * (btnW + spacing);
        let btnY = y + row * (btnH + spacing);
        
        let isSelected = patient.medicalHistory.includes(conditions[i]);
        
        if (isSelected) {
          fill(239, 68, 68, 50);
          stroke(239, 68, 68);
        } else {
          fill(240);
          stroke(200);
        }
        
        strokeWeight(2);
        drawRoundRect(btnX, btnY, btnW, btnH, 8);
        
        fill(isSelected ? 239 : 100, isSelected ? 68 : 100, isSelected ? 68 : 100);
        noStroke();
        textAlign(CENTER, CENTER);
        textSize(max(width * 0.035, 13));  // è‡ªå‹•å­—é«”å¤§å°
        text(conditions[i], btnX + btnW/2, btnY + btnH/2);
      }
    }
    
    function drawTestUI() {
      // è¨ˆæ•¸å™¨
      fill(0, 0, 0, 180);
      noStroke();
      drawRoundRect(20, 20, 150, 80, 15);
      
      fill(255);
      textAlign(LEFT, CENTER);
      textSize(48);
      textStyle(BOLD);
      text(repCount, 40, 45);
      
      fill(200);
      textSize(16);
      text('æ¬¡', 100, 45);
      
      // è¨ˆæ™‚å™¨
      let elapsed = (millis() - timerStartTime) / 1000;
      let remaining = testTypes[currentTest].duration - elapsed;
      displayTime = remaining > 0 ? remaining.toFixed(1) : '0.0';
      
      fill(0, 0, 0, 180);
      drawRoundRect(width - 170, 20, 150, 80, 15);
      
      fill(remaining < 5 ? color(239, 68, 68) : color(16, 185, 129));
      textAlign(CENTER, CENTER);
      textSize(32);
      text(displayTime, width - 95, 45);
      
      fill(200);
      textSize(14);
      text('ç§’', width - 95, 75);
      
      // ç‹€æ…‹æç¤º
      let stateText = '';
      
      switch(currentTest) {
        case 'chairStand':
          if (currentState === 'Sit') stateText = 'è«‹ç«™èµ· â¬†ï¸';
          else if (currentState === 'Stand') stateText = 'è«‹åä¸‹ ğŸª‘';
          else stateText = 'æº–å‚™é–‹å§‹';
          break;
        case 'armCurl':
          if (currentState === 'Curled') stateText = 'ä¼¸ç›´æ‰‹è‡‚';
          else if (currentState === 'Extended') stateText = 'å½æ›²æ‰‹è‡‚';
          else stateText = 'æº–å‚™é–‹å§‹';
          break;
        case 'balance':
          if (balanceLeg) stateText = `${balanceLeg === 'left' ? 'å·¦' : 'å³'}è…³ç«™ç«‹ä¸­`;
          else stateText = 'æŠ¬èµ·ä¸€è…³';
          break;
      }
      
      fill(0, 0, 0, 165);
      let stateW = textWidth(stateText) + 80;
      drawRoundRect(width/2 - stateW/2, height * 0.15, stateW, 65, 20);
      
      fill(255);
      textAlign(CENTER, CENTER);
      textSize(24);
      textStyle(BOLD);
      text(stateText, width/2, height * 0.15 + 32);
      
      // è§’åº¦é¡¯ç¤ºï¼ˆèª¿è©¦ç”¨ï¼‰
      if (kneeAngle || armAngle) {
        let angle = kneeAngle || armAngle;
        let angleText = `è§’åº¦: ${angle.toFixed(0)}Â°`;
        
        fill(0, 0, 0, 150);
        let angleW = textWidth(angleText) + 40;
        drawRoundRect(width/2 - angleW/2, height - 80, angleW, 50, 10);
        
        fill(170);
        textSize(16);
        text(angleText, width/2, height - 55);
      }
    }
    
    function drawSkeleton(landmarks) {
      stroke(16, 185, 129);
      strokeWeight(4);
      noFill();
      
      let connections = [
        [11, 12], [11, 13], [13, 15], [12, 14], [14, 16],
        [11, 23], [12, 24], [23, 24],
        [23, 25], [25, 27], [24, 26], [26, 28]
      ];
      
      for (let conn of connections) {
        let p1 = landmarks[conn[0]];
        let p2 = landmarks[conn[1]];
        if (p1 && p2) {
          let x1 = width - (p1.x * width);
          let y1 = p1.y * height;
          let x2 = width - (p2.x * width);
          let y2 = p2.y * height;
          line(x1, y1, x2, y2);
        }
      }
      
      fill(255, 87, 34);
      noStroke();
      for (let i = 0; i < landmarks.length; i++) {
        let x = width - (landmarks[i].x * width);
        let y = landmarks[i].y * height;
        circle(x, y, 8);
      }
    }
    
    function drawRatingBadge(x, y, rating) {
      let colors = {
        'å„ªç§€': ['16', '185', '129'],
        'è‰¯å¥½': ['59', '130', '246'],
        'æ™®é€š': ['245', '158', '11'],
        'éœ€æ”¹å–„': ['249', '115', '22'],
        'é«˜é¢¨éšª': ['239', '68', '68']
      };
      
      let col = colors[rating] || ['156', '163', '175'];
      
      fill(parseInt(col[0]), parseInt(col[1]), parseInt(col[2]), 30);
      noStroke();
      drawRoundRect(x, y, 120, 50, 10);
      
      fill(parseInt(col[0]), parseInt(col[1]), parseInt(col[2]));
      textAlign(CENTER, CENTER);
      textSize(20);
      textStyle(BOLD);
      text(rating, x + 60, y + 25);
    }
    
    function drawQualityBar(x, y, quality) {
      // èƒŒæ™¯
      fill(240);
      noStroke();
      drawRoundRect(x, y, 300, 30, 15);
      
      // é€²åº¦æ¢
      let barColor = quality >= 80 ? color(16, 185, 129) :
                     quality >= 60 ? color(245, 158, 11) :
                     color(239, 68, 68);
      fill(barColor);
      drawRoundRect(x, y, quality * 3, 30, 15);
      
      // åˆ†æ•¸æ–‡å­—
      fill(60);
      textAlign(CENTER, CENTER);
      textSize(16);
      textStyle(BOLD);
      text(`${quality.toFixed(0)}%`, x + 150, y + 15);
    }
    
    // ==================== è¼”åŠ©å‡½å¼ ====================
    
    function calculateAngle(a, b, c) {
      let radians = Math.atan2(c.y - b.y, c.x - b.x) - Math.atan2(a.y - b.y, a.x - b.x);
      let angle = Math.abs(radians * 180.0 / Math.PI);
      if (angle > 180.0) {
        angle = 360 - angle;
      }
      return angle;
    }
    
    function playSound(type) {
      // ç°¡å–®çš„éŸ³æ•ˆåé¥‹
      if ('AudioContext' in window || 'webkitAudioContext' in window) {
        let audioContext = new (window.AudioContext || window.webkitAudioContext)();
        let oscillator = audioContext.createOscillator();
        let gainNode = audioContext.createGain();
        
        oscillator.connect(gainNode);
        gainNode.connect(audioContext.destination);
        
        oscillator.frequency.value = type === 'count' ? 800 : 400;
        oscillator.type = 'sine';
        
        gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
        gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.1);
        
        oscillator.start(audioContext.currentTime);
        oscillator.stop(audioContext.currentTime + 0.1);
      }
    }
    
    function saveTestResult(session) {
      testHistory.push({
        id: Date.now(),
        patientId: session.patientId,
        patientName: patient.name,
        testType: session.testType,
        testName: testTypes[session.testType].name,
        timestamp: session.endTime,
        result: session.result
      });
      
      localStorage.setItem('medicalTestHistory', JSON.stringify(testHistory));
    }
    
    function loadTestHistory() {
      let stored = localStorage.getItem('medicalTestHistory');
      if (stored) {
        testHistory = JSON.parse(stored);
      }
    }
    
    // ==================== äº‹ä»¶è™•ç† ====================
    
    function mousePressed() {
      switch(phase) {
        case 'home':
          handleHomeClick();
          break;
        case 'patientInfo':
          handlePatientInfoClick();
          break;
        case 'testSelection':
          handleTestSelectionClick();
          break;
        case 'testInstructions':
          handleInstructionsClick();
          break;
        case 'result':
          handleResultClick();
          break;
        case 'history':
          handleHistoryClick();
          break;
      }
    }
    
    function handleHomeClick() {
      // é–‹å§‹æ–°æ¸¬è©¦ - ç›´æ¥é€²å…¥æ¸¬è©¦é¸æ“‡
      if (mouseX > width/2 - 150 && mouseX < width/2 + 150 &&
          mouseY > 280 && mouseY < 350) {
        // è¨­å®šé è¨­å—æ¸¬è€…è³‡æ–™
        patient = { 
          name: 'å—æ¸¬è€…', 
          age: '65', 
          gender: 'ç”·', 
          medicalHistory: [], 
          id: Date.now() 
        };
        phase = 'testSelection';  // ç›´æ¥è·³åˆ°æ¸¬è©¦é¸æ“‡
      }
      
      // æ­·å²è¨˜éŒ„
      if (mouseX > width/2 - 150 && mouseX < width/2 + 150 &&
          mouseY > 380 && mouseY < 450) {
        phase = 'history';
      }
    }
    
    function createPatientInputs() {
      // å§“åè¼¸å…¥æ¡†
      if (nameInput) nameInput.remove();
      nameInput = createInput('');
      nameInput.attribute('placeholder', 'è«‹è¼¸å…¥å§“å');
      
      // æ ¹æ“šè¢å¹•å¤§å°è‡ªå‹•èª¿æ•´æ‰€æœ‰å°ºå¯¸
      let inputHeight = max(height * 0.07, 50);     // è¢å¹•é«˜åº¦çš„ 7%ï¼Œæœ€å° 50px
      let fontSize = max(width * 0.045, 18);        // è¢å¹•å¯¬åº¦çš„ 4.5%ï¼Œæœ€å° 18px
      let padding = max(width * 0.04, 15);          // è‡ªå‹•å…§è·
      
      nameInput.style('font-size', fontSize + 'px');
      nameInput.style('padding', padding + 'px ' + (padding * 1.3) + 'px');
      nameInput.style('height', inputHeight + 'px');
      nameInput.style('border', '2px solid #ddd');
      nameInput.style('border-radius', '12px');
      nameInput.style('width', min(width * 0.85, 540) + 'px');
      nameInput.style('box-sizing', 'border-box');
      nameInput.style('-webkit-appearance', 'none');
      nameInput.input(() => { patient.name = nameInput.value(); });
      
      // å¹´é½¡è¼¸å…¥æ¡†
      if (ageInput) ageInput.remove();
      ageInput = createInput('');
      ageInput.attribute('type', 'number');
      ageInput.attribute('placeholder', 'è«‹è¼¸å…¥å¹´é½¡');
      ageInput.style('font-size', fontSize + 'px');
      ageInput.style('padding', padding + 'px ' + (padding * 1.3) + 'px');
      ageInput.style('height', inputHeight + 'px');
      ageInput.style('border', '2px solid #ddd');
      ageInput.style('border-radius', '12px');
      ageInput.style('width', min(width * 0.85, 540) + 'px');
      ageInput.style('box-sizing', 'border-box');
      ageInput.style('-webkit-appearance', 'none');
      ageInput.input(() => { patient.age = ageInput.value(); });
      
      updateInputPositions();
    }
    
    function updateInputPositions() {
      if (phase !== 'patientInfo') {
        if (nameInput) nameInput.hide();
        if (ageInput) ageInput.hide();
        return;
      }
      
      let cardW = min(width * 0.9, 600);
      let cardX = (width - cardW) / 2;
      let cardY = 150;
      let formX = cardX + 40;
      let formY = cardY + 60;
      
      if (nameInput) {
        nameInput.position(formX, formY + 70);  // åœ¨ã€Œå§“åã€æ¨™ç±¤ä¸‹æ–¹
        nameInput.show();
      }
      
      if (ageInput) {
        ageInput.position(formX, formY + 180);  // å¢åŠ é–“è·åˆ° 180ï¼ˆåŸæœ¬ 160ï¼‰
        ageInput.show();
      }
    }
    
    function handlePatientInfoClick() {
      let cardW = min(width * 0.9, 600);
      let cardX = (width - cardW) / 2;
      let cardY = 150;
      let formX = cardX + 40;
      let formY = cardY + 60;
      
      // æ€§åˆ¥æŒ‰éˆ• - ä½¿ç”¨å‹•æ…‹å°ºå¯¸
      let genders = ['ç”·', 'å¥³'];
      let btnW = max(width * 0.25, 100);
      let btnH = max(height * 0.065, 50);
      let spacing = max(width * 0.04, 15);
      let genderY = formY + 300;
      
      for (let i = 0; i < genders.length; i++) {
        let btnX = formX + i * (btnW + spacing);
        if (mouseX > btnX && mouseX < btnX + btnW &&
            mouseY > genderY && mouseY < genderY + btnH) {
          patient.gender = genders[i];
        }
      }
      
      // ç—…å²å‹¾é¸ - ä½¿ç”¨å‹•æ…‹å°ºå¯¸
      let conditions = ['é«˜è¡€å£“', 'ç³–å°¿ç—…', 'å¿ƒè‡Ÿç—…', 'é—œç¯€ç‚', 'éª¨è³ªç–é¬†'];
      let checkW = max(width * 0.26, 110);
      let checkH = max(height * 0.055, 45);
      let checkSpacing = max(width * 0.02, 10);
      let cols = width < 500 ? 2 : 3;
      let historyY = formY + 420;
      
      for (let i = 0; i < conditions.length; i++) {
        let col = i % cols;
        let row = floor(i / cols);
        let btnX = formX + col * (checkW + checkSpacing);
        let btnY = historyY + row * (checkH + checkSpacing);
        
        if (mouseX > btnX && mouseX < btnX + checkW &&
            mouseY > btnY && mouseY < btnY + checkH) {
          let index = patient.medicalHistory.indexOf(conditions[i]);
          if (index > -1) {
            patient.medicalHistory.splice(index, 1);
          } else {
            patient.medicalHistory.push(conditions[i]);
          }
        }
      }
      
      // ä¸‹ä¸€æ­¥æŒ‰éˆ•
      let canProceed = patient.name && patient.age && patient.gender;
      if (canProceed) {
        if (mouseX > width/2 - 100 && mouseX < width/2 + 100 &&
            mouseY > cardY + (min(height * 0.75, 700)) - 80 &&
            mouseY < cardY + (min(height * 0.75, 700)) - 20) {
          phase = 'testSelection';
          if (nameInput) nameInput.hide();
          if (ageInput) ageInput.hide();
        }
      }
      
      // è¿”å›æŒ‰éˆ•
      if (mouseX > 20 && mouseX < 70 && mouseY > 20 && mouseY < 70) {
        phase = 'home';
        if (nameInput) nameInput.hide();
        if (ageInput) ageInput.hide();
      }
    }
    
    function handleTestSelectionClick() {
      let startY = 150;
      let cardSpacing = 20;
      let cardH = 180;
      let cardW = min(width * 0.9, 500);
      let cardX = (width - cardW) / 2;
      
      let tests = Object.keys(testTypes);
      
      for (let i = 0; i < tests.length; i++) {
        let y = startY + i * (cardH + cardSpacing);
        
        if (mouseX > cardX && mouseX < cardX + cardW &&
            mouseY > y && mouseY < y + cardH) {
          currentTest = tests[i];
          phase = 'testInstructions';
        }
      }
      
      // è¿”å›æŒ‰éˆ• - è¿”å›é¦–é 
      if (mouseX > 20 && mouseX < 70 && mouseY > 20 && mouseY < 70) {
        phase = 'home';
      }
    }
    
    function handleInstructionsClick() {
      // é–‹å§‹æ¸¬è©¦æŒ‰éˆ•
      if (mouseX > width/2 - 100 && mouseX < width/2 + 100 &&
          mouseY > height - 140 && mouseY < height - 80) {
        startTest();
      }
      
      // è¿”å›æŒ‰éˆ•
      if (mouseX > 20 && mouseX < 70 && mouseY > 20 && mouseY < 70) {
        phase = 'testSelection';
      }
    }
    
    function handleResultClick() {
      // å„²å­˜å ±å‘Š
      if (mouseX > width/2 - 220 && mouseX < width/2 - 20 &&
          mouseY > height - 100 && mouseY < height - 40) {
        alert('å ±å‘Šå·²å„²å­˜ï¼');
      }
      
      // è¿”å›é¦–é 
      if (mouseX > width/2 + 20 && mouseX < width/2 + 220 &&
          mouseY > height - 100 && mouseY < height - 40) {
        phase = 'home';
        currentTest = null;
        testSession = null;
      }
    }
    
    function handleHistoryClick() {
      // è¿”å›æŒ‰éˆ•
      if (mouseX > 20 && mouseX < 70 && mouseY > 20 && mouseY < 70) {
        phase = 'home';
      }
    }
    
    function touchStarted() {
      mousePressed();
      return false;
    }
    
    function windowResized() {
      resizeCanvas(windowWidth, windowHeight);
      updateInputPositions();
    }
  </script>
</body>
</html>
